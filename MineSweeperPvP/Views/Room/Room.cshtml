@{
    var roomId = ViewBag.RoomId as string;
    var playerNumber = (int)ViewBag.PlayerNumber;
}
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>Room @roomId</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.0/signalr.min.js"></script>
    <style>
        .grid { display: inline-block; margin: 10px; }
        .cell { width: 28px; height: 28px; border: 1px solid #666; display:inline-block; vertical-align:top; text-align:center; line-height:28px; font-weight:bold; background:#444; color:#fff; user-select:none; }
        .opened { background:#bbb; color:#000;}
        .bomb { background:#900; }
    </style>
</head>
<body>
    <h3>Room: @roomId — You are Player @playerNumber</h3>
    <div>
        <button id="startBtn">Start Game</button>
    </div>
    <div id="info"></div>

    <div>
        <div class="grid" id="grid-player1"></div>
        <div class="grid" id="grid-player2"></div>
    </div>

    <script>
        // Config
        const ROWS = 10, COLS = 10, BOMBS = 15;
        const roomId = "@roomId";
        const playerNumber = @playerNumber;

        // Each player has own grid state in client side. We'll generate same board for both players to be symmetric.
        let board = null;
        function makeBoard(rows, cols, bombs) {
          // create array of cells: {r,c,isBomb,adj,opened}
          const arr = Array(rows).fill(0).map(() => Array(cols).fill(0).map(() => ({ isBomb:false, adj:0, opened:false })));
          // place bombs random
          let placed = 0;
          while (placed < bombs) {
            const r = Math.floor(Math.random()*rows), c = Math.floor(Math.random()*cols);
            if (!arr[r][c].isBomb) { arr[r][c].isBomb = true; placed++; }
          }
          // compute adj
          const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
          for (let r=0;r<rows;r++) for (let c=0;c<cols;c++){
            if (arr[r][c].isBomb) continue;
            let count=0;
            dirs.forEach(d=>{
              const nr=r+d[0], nc=c+d[1];
              if (nr>=0 && nr<rows && nc>=0 && nc<cols && arr[nr][nc].isBomb) count++;
            });
            arr[r][c].adj = count;
          }
          return arr;
        }

        function renderGrid(containerId, boardState, clickable=true) {
          const container = document.getElementById(containerId);
          container.innerHTML = "";
          for (let r=0;r<ROWS;r++){
            const rowDiv = document.createElement("div");
            for (let c=0;c<COLS;c++){
              const cell = boardState[r][c];
              const el = document.createElement("div");
              el.className = "cell" + (cell.opened ? " opened" : "");
              el.dataset.r = r; el.dataset.c = c;
              el.textContent = cell.opened ? (cell.isBomb ? "💣" : (cell.adj===0 ? "" : cell.adj)) : "";
              if (cell.opened && cell.isBomb) el.classList.add("bomb");
              if (clickable) {
                el.addEventListener("click", onCellClick);
              }
              rowDiv.appendChild(el);
            }
            container.appendChild(rowDiv);
          }
        }

        function openCell(boardState, r, c) {
          if (r<0||c<0||r>=ROWS||c>=COLS) return;
          const cell = boardState[r][c];
          if (cell.opened) return;
          cell.opened = true;
          if (cell.adj === 0 && !cell.isBomb) {
            // flood fill
            const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
            dirs.forEach(d => openCell(boardState, r+d[0], c+d[1]));
          }
        }

        function countSafeLeft(boardState) {
          let total = 0, opened = 0;
          for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
            if (!boardState[r][c].isBomb) total++;
            if (boardState[r][c].opened && !boardState[r][c].isBomb) opened++;
          }
          return total - opened;
        }

        // per-player local boards
        let boardP1 = null;
        let boardP2 = null;

        // SignalR connection
        const connection = new signalR.HubConnectionBuilder().withUrl("/gamehub").build();
        connection.start().then(() => {
          document.getElementById("info").innerText += "Connected to server. ";
          connection.invoke("JoinRoom", roomId);
        });

        connection.on("PlayerJoined", (count) => {
          document.getElementById("info").innerText = "Players in room: " + count;
        });

        connection.on("PlayerFinished", (pNumber) => {
          const winner = pNumber === 1 ? "Player 1" : "Player 2";
          alert(winner + " finished first! Game over.");
          // record match by calling server endpoint /Game/Record?roomId=... but leave to server side
        });

        connection.on("ResetGrid", () => {
          // reset only this client (if this client clicked bomb)
          if (playerNumber === 1) { boardP1 = makeBoard(ROWS,COLS,BOMBS); renderGrid("grid-player1", boardP1); }
          else { boardP2 = makeBoard(ROWS,COLS,BOMBS); renderGrid("grid-player2", boardP2); }
          alert("You clicked a bomb! Your grid has been reset.");
        });

        connection.on("OpponentLeft", () => {
          alert("Opponent left the room.");
        });

        // cell click handler
        function onCellClick(e) {
          const r = parseInt(this.dataset.r), c = parseInt(this.dataset.c);
          const targetBoard = (playerNumber === 1 && this.closest("#grid-player1")) || (playerNumber === 2 && this.closest("#grid-player2"));
          // Which player's board clicked? Only allow clicking on your own grid.
          // We're binding clicks only to own grid below.
          const myBoard = (this.parentElement.parentElement.id === "grid-player1") ? boardP1 : boardP2;
          const cell = myBoard[r][c];
          if (cell.opened) return;
          if (cell.isBomb) {
            // notify server to reset this player's grid
            connection.invoke("BombClicked", roomId, connection.connectionId).catch(console.error);
            // But hub cannot access connectionId client-side easily; we pass the current client connection id not available.
            // Instead, hub method BombClicked can accept no connectionId and the hub can send ResetGrid to caller. Simpler change below.
            // However here we also locally reset to keep UX snappy:
            if (myBoard === boardP1) { boardP1 = makeBoard(ROWS,COLS,BOMBS); renderGrid("grid-player1", boardP1); }
            else { boardP2 = makeBoard(ROWS,COLS,BOMBS); renderGrid("grid-player2", boardP2); }
            alert("Boom! You clicked bomb — your grid was reset.");
            return;
          }
          openCell(myBoard, r, c);
          renderGrid(myBoard === boardP1 ? "grid-player1" : "grid-player2", myBoard);
          // check finish
          if (countSafeLeft(myBoard) === 0) {
            // notify hub that this player finished
            connection.invoke("PlayerFinished", roomId, playerNumber);
          }
        }

        document.getElementById("startBtn").addEventListener("click", () => {
          // generate board for both players; for fairness we generate and set both boards same (or different if you want)
          board = makeBoard(ROWS,COLS,BOMBS);
          // clone for both players
          boardP1 = JSON.parse(JSON.stringify(board));
          boardP2 = JSON.parse(JSON.stringify(board));
          // Only allow clicking on your own grid
          renderGrid("grid-player1", boardP1, playerNumber === 1);
          renderGrid("grid-player2", boardP2, playerNumber === 2);
          document.getElementById("info").innerText = "Game started!";
        });
    </script>
</body>
</html>
